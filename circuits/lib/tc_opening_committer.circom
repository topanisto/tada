pragma circom 2.1.6;

include "../../node_modules/circomlib/circuits/bitify.circom"; 
include "../../node_modules/circomlib/circuits/gates.circom";


template CommitterTCOpening(k, N) {
    """
    ZKP of knowledge of committed value m to a timed commitment, 
    generated by a committer. Used in Encryption-TADA to prove that
    the committed value is equal to the preimage of an encrypted value.
    Much faster than TCOpening since the starting exponent is known!

    The full structure of a timed commitment is
        {<h, g, u, S>, W, exp_primes}
    Only g, S, W, and m are necessary inputs to this circuit.
    """
    // get number of bits of N
    var n_bits = 0;
    var temp = N;
    while (temp > 0) {
        n_bits = n_bits + 1;
        temp = temp \ 2;  // Integer division by 2
    }

    // generator
    signal input g;
    // commitment body
    signal input S[256];
    // verification vector := <g^{2^{2^i}> for 0 <= i <= k
    signal input W[k+1];

    // check W is generated correctly
    component gmodN = ModuloOperator(N, 252);
    signal g_2 <== g * g;
    gmodN.in <== g_2;
    W[0] === gmodN.out;

    // private msg
    signal input m;
    component m2bits = Num2Bits(256);
    m2bits.in <== m;

    // priv v_exp_gen := 2^(2^k-256)
    // TODO: potentially have l be a parameter to the circuit so we can
    // directly take as input v_exp := 2^(2^k-l)
    // TODO: do we need to constrain this further??
    signal v_exp_gen;
    component v_exp2bits = Num2Bits(n_bits);
    v_exp2bits.in <== v_exp_gen;

    signal output out;

    // compute g^v_exp
    // a vector of <g^1, g^2^i> ...
    signal g_powers[n_bits];
    g_powers[0] <== g;

    // signals for mod N operations
    component mods_gpow[n_bits-1];
    signal temp_gpow[n_bits-1];
    for (var i = 1; i < n_bits; i++) {
        mods_gpow[i-1] = ModuloOperator(N, 252);
        temp_gpow[i-1] <-- powers[i-1] * powers[i-1];
        mods_gpow[i-1].in <== temp_gpow[i-1];
        g_powers[i] <== mods_gpow[i-1].out;
    }

    // then multiply bits and corresponding powers together
    signal start_exponent_accumulator[n_bits];
    start_exponent_accumulator[0] <== g_powers[0] * exponent_bits.out[0];

    component mods_acc[n_bits-1];
    signal temp_acc[n_bits-1];
    for (var i=1; i< n_bits; i++) {
        mods_acc[i-1] = ModuloOperator(N, 252);
        temp_acc[i-1] <== start_exponent_accumulator[i-1] + g_powers[i] * v_exp2bits.out[i];
        mods_acc[i-1].in <== temp_acc[i-1];
        start_exponent_accumulator[i] <== mods_acc[i-1].out;
    }

    // get remainder of blinded values-- only need to allocate 256
    signal g_exp[256];
    g_exp[0] <== start_exponent_accumulator[n_bits-1];

    component mods_blinded[255];
    signal temp_blinded[255];
    for (var i=1; i < 256; i++) {
        mods_blinded[i-1] = ModuloOperator(N, 252);
        temp_blinded[i-1] <== g_exp[i-1] * g_exp[i-1];
        mods_blinded[i-1].in <== temp_blinded[i-1];
        g_exp[i] <== mods_blinded[i-1].out;
    }

    // we can proceed now as usual..
    component xors[256];
    signal LSB[256]; // 
    component getlsb[256];

    // compare bitwise
    signal res_comp[257];
    res_comp[0] <== 1;
    component comp[256];

    // check s[i] = m_bits[i] XOR lsb(g^{2^{2^k-i}})
    for (var i=0; i<256; i++) {
        var j = 2**(k-1) - i -1; // index 
        // calculate LSB
        getlsb[i] = Num2Bits(n_bits);
        getlsb[i].in <== g_exp[j];
        LSB[i] <== getlsb[i].out[0];

        xors[i] = XOR(); // new XOR gate
        xors[i].a <== m2bits.out[i];
        xors[i].b <== LSB[i];

        // compare S[i] to computed XOR
        comp[i] = IsEqual();
        comp[i].in[0] <== S[i];
        comp[i].in[1] <== xors[i].out;

        // need an AND function
        res_comp[i+1] <== comp[i].out * res_comp[i];
    }

    // TODO: fix output
    out <== res_comp[256];
}